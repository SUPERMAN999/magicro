<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1e293b">
    <title>GENIUS Matrix - MAGIC Mobile</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: manipulation;
        }
        * {
            -webkit-tap-highlight-color: transparent;
        }
        .translating {
            opacity: 0.6;
        }
        .dragging {
            opacity: 0.5;
        }
        .drag-over {
            background-color: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6 !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // EXPANDED DICTIONARY - Same as desktop
        const dictionary = {
            'en_to_ro': {
                // Work related
                'meeting': 'Ã®ntÃ¢lnire',
                'call': 'sunÄƒ',
                'email': 'email',
                'send email': 'trimite email',
                'urgent': 'urgent',
                'important': 'important',
                'deadline': 'termen limitÄƒ',
                'project': 'proiect',
                'task': 'sarcinÄƒ',
                'work': 'muncÄƒ',
                'report': 'raport',
                'presentation': 'prezentare',
                'review': 'revizuire',
                'approve': 'aprobare',
                'complete': 'completeazÄƒ',
                'finish': 'terminÄƒ',
                'start': 'Ã®ncepe',
                'schedule': 'programeazÄƒ',
                'plan': 'planificÄƒ',
                'organize': 'organizeazÄƒ',
                'prepare': 'pregÄƒteÈ™te',
                'submit': 'trimite',
                'file': 'fiÈ™ier',
                'document': 'document',
                'contract': 'contract',
                'invoice': 'facturÄƒ',
                'budget': 'buget',
                'expense': 'cheltuialÄƒ',
                'proposal': 'propunere',
                'strategy': 'strategie',
                'analysis': 'analizÄƒ',
                
                // Personal tasks
                'buy groceries': 'cumpÄƒrÄƒ alimente',
                'groceries': 'alimente',
                'shopping': 'cumpÄƒrÄƒturi',
                'buy': 'cumpÄƒrÄƒ',
                'sell': 'vinde',
                'pay': 'plÄƒteÈ™te',
                'pay bills': 'plÄƒteÈ™te facturile',
                'bills': 'facturi',
                'home': 'acasÄƒ',
                'family': 'familie',
                'kids': 'copii',
                'children': 'copii',
                'school': 'È™coalÄƒ',
                'homework': 'temÄƒ',
                'clean': 'curÄƒÈ›Äƒ',
                'laundry': 'rufe',
                'cook': 'gÄƒteÈ™te',
                'dinner': 'cinÄƒ',
                'lunch': 'prÃ¢nz',
                'breakfast': 'micul dejun',
                
                // Health & appointments
                'call doctor': 'sunÄƒ doctorul',
                'call the doctor': 'sunÄƒ doctorul',
                'go to the doctor': 'du-te la doctor',
                'go to doctor': 'du-te la doctor',
                'see the doctor': 'vezi doctorul',
                'visit doctor': 'viziteazÄƒ doctorul',
                'doctor': 'doctor',
                'dentist': 'dentist',
                'appointment': 'programare',
                'hospital': 'spital',
                'pharmacy': 'farmacie',
                'medicine': 'medicament',
                'exercise': 'exerciÈ›iu',
                'workout': 'antrenament',
                'gym': 'salÄƒ',
                'health': 'sÄƒnÄƒtate',
                
                // Communication
                'call mom': 'sunÄƒ mama',
                'call dad': 'sunÄƒ tata',
                'text': 'mesaj',
                'message': 'mesaj',
                'reply': 'rÄƒspunde',
                'respond': 'rÄƒspunde',
                'contact': 'contacteazÄƒ',
                'phone': 'telefon',
                
                // Actions
                'fix': 'reparÄƒ',
                'repair': 'reparÄƒ',
                'update': 'actualizeazÄƒ',
                'cancel': 'anuleazÄƒ',
                'confirm': 'confirmÄƒ',
                'book': 'rezervÄƒ',
                'reserve': 'rezervÄƒ',
                'order': 'comandÄƒ',
                'return': 'returneazÄƒ',
                'exchange': 'schimbÄƒ',
                'pickup': 'ridicÄƒ',
                'deliver': 'livreazÄƒ',
                'ship': 'expediazÄƒ',
                
                // Time related
                'today': 'astÄƒzi',
                'tomorrow': 'mÃ¢ine',
                'tonight': 'Ã®n seara asta',
                'this week': 'sÄƒptÄƒmÃ¢na aceasta',
                'next week': 'sÄƒptÄƒmÃ¢na viitoare',
                'urgent task': 'sarcinÄƒ urgentÄƒ',
                'asap': 'cÃ¢t mai curÃ¢nd',
                
                // Common phrases
                'go to': 'du-te la',
                'go to work': 'du-te la muncÄƒ',
                'go home': 'du-te acasÄƒ',
                'pick up': 'ridicÄƒ',
                'drop off': 'lasÄƒ',
                'follow up': 'urmÄƒreÈ™te',
                'check in': 'Ã®nregistreazÄƒ-te',
                'sign up': 'Ã®nscrie-te',
                'log in': 'autentificÄƒ-te',
                'back up': 'salveazÄƒ'
            },
            'ro_to_en': {
                'Ã®ntÃ¢lnire': 'meeting',
                'sunÄƒ': 'call',
                'email': 'email',
                'trimite email': 'send email',
                'urgent': 'urgent',
                'important': 'important',
                'termen limitÄƒ': 'deadline',
                'proiect': 'project',
                'sarcinÄƒ': 'task',
                'muncÄƒ': 'work',
                'raport': 'report',
                'prezentare': 'presentation',
                'revizuire': 'review',
                'aprobare': 'approve',
                'completeazÄƒ': 'complete',
                'terminÄƒ': 'finish',
                'Ã®ncepe': 'start',
                'programeazÄƒ': 'schedule',
                'planificÄƒ': 'plan',
                'organizeazÄƒ': 'organize',
                'pregÄƒteÈ™te': 'prepare',
                'trimite': 'submit',
                'fiÈ™ier': 'file',
                'document': 'document',
                'contract': 'contract',
                'facturÄƒ': 'invoice',
                'buget': 'budget',
                'cheltuialÄƒ': 'expense',
                'propunere': 'proposal',
                'strategie': 'strategy',
                'analizÄƒ': 'analysis',
                'cumpÄƒrÄƒ alimente': 'buy groceries',
                'alimente': 'groceries',
                'cumpÄƒrÄƒturi': 'shopping',
                'cumpÄƒrÄƒ': 'buy',
                'vinde': 'sell',
                'plÄƒteÈ™te': 'pay',
                'plÄƒteÈ™te facturile': 'pay bills',
                'facturi': 'bills',
                'acasÄƒ': 'home',
                'familie': 'family',
                'copii': 'kids',
                'È™coalÄƒ': 'school',
                'temÄƒ': 'homework',
                'curÄƒÈ›Äƒ': 'clean',
                'rufe': 'laundry',
                'gÄƒteÈ™te': 'cook',
                'cinÄƒ': 'dinner',
                'prÃ¢nz': 'lunch',
                'micul dejun': 'breakfast',
                'sunÄƒ doctorul': 'call doctor',
                'du-te la doctor': 'go to the doctor',
                'vezi doctorul': 'see the doctor',
                'viziteazÄƒ doctorul': 'visit doctor',
                'doctor': 'doctor',
                'dentist': 'dentist',
                'programare': 'appointment',
                'spital': 'hospital',
                'farmacie': 'pharmacy',
                'medicament': 'medicine',
                'exerciÈ›iu': 'exercise',
                'antrenament': 'workout',
                'salÄƒ': 'gym',
                'sÄƒnÄƒtate': 'health',
                'sunÄƒ mama': 'call mom',
                'sunÄƒ tata': 'call dad',
                'mesaj': 'message',
                'rÄƒspunde': 'reply',
                'contacteazÄƒ': 'contact',
                'telefon': 'phone',
                'reparÄƒ': 'fix',
                'actualizeazÄƒ': 'update',
                'anuleazÄƒ': 'cancel',
                'confirmÄƒ': 'confirm',
                'rezervÄƒ': 'book',
                'comandÄƒ': 'order',
                'returneazÄƒ': 'return',
                'schimbÄƒ': 'exchange',
                'ridicÄƒ': 'pickup',
                'livreazÄƒ': 'deliver',
                'expediazÄƒ': 'ship',
                'astÄƒzi': 'today',
                'mÃ¢ine': 'tomorrow',
                'Ã®n seara asta': 'tonight',
                'sÄƒptÄƒmÃ¢na aceasta': 'this week',
                'sÄƒptÄƒmÃ¢na viitoare': 'next week',
                'sarcinÄƒ urgentÄƒ': 'urgent task',
                'cÃ¢t mai curÃ¢nd': 'asap',
                'du-te la': 'go to',
                'du-te la muncÄƒ': 'go to work',
                'du-te acasÄƒ': 'go home',
                'lasÄƒ': 'drop off',
                'urmÄƒreÈ™te': 'follow up',
                'Ã®nregistreazÄƒ-te': 'check in',
                'Ã®nscrie-te': 'sign up',
                'autentificÄƒ-te': 'log in',
                'salveazÄƒ': 'back up'
            }
        };

        // Translation function
        async function translateText(text, targetLang, sourceLang = 'en') {
            try {
                const langMap = {
                    'en': 'en',
                    'fr': 'fr',
                    'fr_ca': 'fr'
                };
                
                const targetCode = langMap[targetLang];
                const sourceCode = langMap[sourceLang];
                
                if (sourceCode === targetCode) {
                    return text;
                }

                // STEP 1: Try dictionary
                const dictKey = `${sourceCode}_to_${targetCode}`;
                const lowerText = text.toLowerCase().trim();
                
                if (dictionary[dictKey] && dictionary[dictKey][lowerText]) {
                    console.log('âœ… Dictionary:', text, 'â†’', dictionary[dictKey][lowerText]);
                    return dictionary[dictKey][lowerText];
                }

                // STEP 2: Word-by-word (ONLY if ALL words translate)
                const words = text.split(' ');
                if (words.length > 1 && words.length <= 5) {
                    const translatedWords = words.map(word => {
                        const lowerWord = word.toLowerCase();
                        return dictionary[dictKey]?.[lowerWord] || null;
                    });
                    
                    if (translatedWords.every(w => w !== null)) {
                        const result = translatedWords.join(' ');
                        console.log('âœ… Word-by-word:', text, 'â†’', result);
                        return result;
                    }
                }

                // STEP 3: API
                try {
                    const response = await fetch(
                        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceCode}|${targetCode}`
                    );
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.responseData && data.responseData.translatedText) {
                            console.log('âœ… API:', text, 'â†’', data.responseData.translatedText);
                            return data.responseData.translatedText;
                        }
                    }
                } catch (e) {
                    console.log('âš ï¸ API unavailable');
                }

                console.warn('âŒ Translation failed:', text);
                return `[${text}]`;
                
            } catch (error) {
                console.error('Translation error:', error);
                return text;
            }
        }

        // UI Translations
        const translations = {
            en: {
                appTitle: "GENIUS Matrix",
                appSubtitle: "Get Every Notable Issue Expertly Sorted",
                exportTasks: "Export",
                importTasks: "Import",
                clearAll: "Clear All",
                clearConfirm: "Clear all tasks?",
                addTask: "Add",
                addTo: "Add to:",
                enterTask: "Enter your task...",
                cancel: "Cancel",
                save: "Save",
                edit: "Edit",
                importSuccess: "Tasks imported!",
                importError: "Error: Invalid file",
                noTasks: "No tasks yet",
                tasksSaved: "Auto-saved â€¢ Drag to move",
                totalTasks: "total",
                language: "Language",
                translating: "Translating...",
                dragHint: "Long press to drag",
                voiceInput: "ðŸŽ¤ Voice",
                listening: "Listening...",
                speak: "ðŸ”Š",
                stopSpeaking: "Stop",
                quadrants: {
                    urgent_important: {
                        title: "Do First",
                        subtitle: "Urgent & Important",
                        emoji: "ðŸ”¥",
                        description: "Critical tasks requiring immediate attention",
                        action: "Do immediately"
                    },
                    not_urgent_important: {
                        title: "Schedule",
                        subtitle: "Not Urgent & Important",
                        emoji: "ðŸ“…",
                        description: "Strategic work for long-term success",
                        action: "Plan & schedule"
                    },
                    urgent_not_important: {
                        title: "Delegate",
                        subtitle: "Urgent & Not Important",
                        emoji: "ðŸ‘¥",
                        description: "Tasks that can be handled by others",
                        action: "Delegate or minimize"
                    },
                    not_urgent_not_important: {
                        title: "Eliminate",
                        subtitle: "Not Urgent & Not Important",
                        emoji: "ðŸ—‘ï¸",
                        description: "Low-value activities to avoid",
                        action: "Eliminate or defer"
                    }
                }
            },
            ro: {
                appTitle: "Matricea de Decizie GENIUS",
                appSubtitle: "GestioneazÄƒ Eficient Fiecare NotÄƒ ImportantÄƒ È™i UrgentÄƒ SortatÄƒ",
                exportTasks: "ExportÄƒ Sarcini",
                importTasks: "ImportÄƒ Sarcini",
                clearAll: "È˜terge Tot",
                clearConfirm: "Sigur doriÈ›i sÄƒ È™tergeÈ›i toate sarcinile? AceastÄƒ acÈ›iune nu poate fi anulatÄƒ.",
                addTask: "AdaugÄƒ SarcinÄƒ",
                addTo: "AdaugÄƒ la:",
                enterTask: "Introdu sarcina sau decizia ta...",
                cancel: "AnuleazÄƒ",
                save: "SalveazÄƒ",
                edit: "EditeazÄƒ",
                importSuccess: "Sarcini importate cu succes!",
                importError: "Eroare la import. AsigurÄƒ-te cÄƒ este un fiÈ™ier JSON valid.",
                noTasks: "Nicio sarcinÄƒ",
                tasksSaved: "Salvat automat â€¢ Trage pentru a muta",
                totalTasks: "total",
                language: "LimbÄƒ",
                translating: "Se traduce...",
                editTranslation: "Click pentru a edita traducerea",
                dragHint: "ApasÄƒ lung pentru a trage",
                voiceInput: "ðŸŽ¤ Voce",
                listening: "Ascult...",
                speak: "ðŸ”Š",
                stopSpeaking: "OpreÈ™te",
                quadrants: {
                    urgent_important: {
                        title: "FÄƒ Mai ÃŽntÃ¢i",
                        subtitle: "Urgent È™i Important",
                        emoji: "ðŸ”¥",
                        description: "Sarcini critice care necesitÄƒ atenÈ›ie imediatÄƒ",
                        action: "FÄƒ imediat"
                    },
                    not_urgent_important: {
                        title: "ProgrameazÄƒ",
                        subtitle: "Nu Urgent È™i Important",
                        emoji: "ðŸ“…",
                        description: "MuncÄƒ strategicÄƒ pentru succes pe termen lung",
                        action: "PlanificÄƒ È™i programeazÄƒ"
                    },
                    urgent_not_important: {
                        title: "Delege",
                        subtitle: "Urgent È™i Nu Important",
                        emoji: "ðŸ‘¥",
                        description: "Sarcini care pot fi gestionate de alÈ›ii",
                        action: "Delege sau minimizeazÄƒ"
                    },
                    not_urgent_not_important: {
                        title: "EliminÄƒ",
                        subtitle: "Nu Urgent È™i Nu Important",
                        emoji: "ðŸ—‘ï¸",
                        description: "ActivitÄƒÈ›i de valoare scÄƒzutÄƒ de evitat",
                        action: "EliminÄƒ sau amÃ¢nÄƒ"
                    }
                }
            }
        };

        // Icons
        const Plus = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );

        const Trash2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                <line x1="10" y1="11" x2="10" y2="17"></line>
                <line x1="14" y1="11" x2="14" y2="17"></line>
            </svg>
        );

        const Edit2 = ({ size = 18 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
            </svg>
        );

        const Menu = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="3" y1="12" x2="21" y2="12"></line>
                <line x1="3" y1="6" x2="21" y2="6"></line>
                <line x1="3" y1="18" x2="21" y2="18"></line>
            </svg>
        );

        const X = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const Download = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const Upload = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const Globe = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
            </svg>
        );

        const Move = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="5 9 2 12 5 15"></polyline>
                <polyline points="9 5 12 2 15 5"></polyline>
                <polyline points="15 19 12 22 9 19"></polyline>
                <polyline points="19 9 22 12 19 15"></polyline>
                <line x1="2" y1="12" x2="22" y2="12"></line>
                <line x1="12" y1="2" x2="12" y2="22"></line>
            </svg>
        );

        const Mic = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" y1="19" x2="12" y2="23"></line>
                <line x1="8" y1="23" x2="16" y2="23"></line>
            </svg>
        );

        const Volume2 = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
        );

        function DecisionMatrix() {
            const [tasks, setTasks] = useState([]);
            const [newTask, setNewTask] = useState('');
            const [selectedQuadrant, setSelectedQuadrant] = useState(null);
            const [showMenu, setShowMenu] = useState(false);
            const [language, setLanguage] = useState('en');
            const [isTranslating, setIsTranslating] = useState(false);
            const [editingTask, setEditingTask] = useState(null);
            const [editText, setEditText] = useState('');
            const [draggedTask, setDraggedTask] = useState(null);
            const [dragOverQuadrant, setDragOverQuadrant] = useState(null);
            const [dragOverTask, setDragOverTask] = useState(null);
            const [touchStartY, setTouchStartY] = useState(null);
            const [touchCurrentY, setTouchCurrentY] = useState(null);
            const [isListening, setIsListening] = useState(false);
            const [isSpeaking, setIsSpeaking] = useState(false);

            useEffect(() => {
                const saved = localStorage.getItem('geniusTasks');
                if (saved) {
                    const loadedTasks = JSON.parse(saved);
                    // Initialize order for tasks that don't have it
                    const tasksWithOrder = loadedTasks.map((task, index) => {
                        if (task.order === undefined) {
                            const quadrantTasks = loadedTasks.filter(t => t.quadrant === task.quadrant);
                            const orderInQuadrant = quadrantTasks.indexOf(task);
                            return { ...task, order: orderInQuadrant };
                        }
                        return task;
                    });
                    setTasks(tasksWithOrder);
                } else {
                    setTasks([]);
                }
                const savedLang = localStorage.getItem('geniusLanguage');
                if (savedLang) {
                    setLanguage(savedLang);
                }
            }, []);

            useEffect(() => {
                localStorage.setItem('geniusTasks', JSON.stringify(tasks));
            }, [tasks]);

            useEffect(() => {
                localStorage.setItem('geniusLanguage', language);
            }, [language]);

            useEffect(() => {
                const translateAllTasks = async () => {
                    if (tasks.length === 0) return;
                    
                    setIsTranslating(true);
                    
                    const translatedTasks = await Promise.all(
                        tasks.map(async (task) => {
                            if (!task.translations || !task.translations[language]) {
                                const sourceLang = task.sourceLang || 'en';
                                const sourceText = task.translations?.[sourceLang] || task.text;
                                const translated = await translateText(sourceText, language, sourceLang);
                                
                                return {
                                    ...task,
                                    translations: {
                                        ...task.translations,
                                        [language]: translated
                                    }
                                };
                            }
                            return task;
                        })
                    );
                    
                    setTasks(translatedTasks);
                    setIsTranslating(false);
                };
                
                translateAllTasks();
            }, [language]);

            const t = translations[language];

            // Voice Recognition
            const startVoiceInput = () => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    alert('Voice recognition is not supported in your browser. Please use Chrome, Edge, or Safari.');
                    return;
                }

                const recognition = new SpeechRecognition();
                recognition.lang = language === 'en' ? 'en-US' : 'ro-RO';
                recognition.interimResults = true; // Changed to true to get interim results
                recognition.maxAlternatives = 1;
                recognition.continuous = false; // Single result

                console.log('ðŸŽ¤ Starting recognition with language:', recognition.lang);

                recognition.onstart = () => {
                    setIsListening(true);
                    console.log('âœ… Voice recognition started - speak now!');
                };

                recognition.onresult = (event) => {
                    console.log('ðŸ“ Got result event:', event);
                    
                    // Get the transcript from the last result
                    const results = event.results;
                    const lastResultIndex = results.length - 1;
                    const transcript = results[lastResultIndex][0].transcript;
                    
                    console.log('âœ… Voice captured:', transcript);
                    console.log('Is final:', results[lastResultIndex].isFinal);
                    console.log('ðŸ”„ Calling setNewTask with:', transcript);
                    
                    // Update text field with interim results too
                    setNewTask(transcript);
                    
                    console.log('âœ… setNewTask called successfully');
                    
                    // If it's the final result, stop listening
                    if (results[lastResultIndex].isFinal) {
                        console.log('âœ… Final result captured');
                        setIsListening(false);
                    }
                };

                recognition.onspeechstart = () => {
                    console.log('ðŸ—£ï¸ Speech detected!');
                };

                recognition.onspeechend = () => {
                    console.log('ðŸ”‡ Speech ended');
                };

                recognition.onaudiostart = () => {
                    console.log('ðŸŽ™ï¸ Audio capture started');
                };

                recognition.onaudioend = () => {
                    console.log('ðŸŽ™ï¸ Audio capture ended');
                };

                recognition.onerror = (event) => {
                    console.error('âŒ Voice error:', event.error);
                    setIsListening(false);
                    
                    let errorMessage = 'Voice recognition error: ';
                    switch(event.error) {
                        case 'no-speech':
                            errorMessage += 'No speech detected. Please try again and speak clearly.';
                            break;
                        case 'audio-capture':
                            errorMessage += 'Microphone not found or not working.';
                            break;
                        case 'not-allowed':
                            errorMessage += 'Microphone access denied. Please allow microphone access in your browser settings.';
                            break;
                        case 'network':
                            errorMessage += 'Network error. Voice recognition needs internet connection.';
                            break;
                        case 'aborted':
                            errorMessage += 'Voice recognition was aborted.';
                            break;
                        default:
                            errorMessage += event.error;
                    }
                    alert(errorMessage);
                };

                recognition.onend = () => {
                    console.log('ðŸ Voice recognition ended');
                    setIsListening(false);
                };

                try {
                    recognition.start();
                    console.log('ðŸš€ Recognition start command sent');
                } catch (err) {
                    console.error('âŒ Failed to start recognition:', err);
                    alert('Could not start voice recognition: ' + err.message);
                    setIsListening(false);
                }
            };

            // Text to Speech
            const speakTask = (taskText) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(taskText);
                    utterance.lang = language === 'en' ? 'en-US' : 'ro-RO';
                    utterance.onstart = () => setIsSpeaking(true);
                    utterance.onend = () => setIsSpeaking(false);
                    window.speechSynthesis.speak(utterance);
                }
            };

            const quadrants = {
                urgent_important: {
                    ...t.quadrants.urgent_important,
                    color: 'bg-red-50 border-red-300',
                    headerColor: 'bg-red-500'
                },
                not_urgent_important: {
                    ...t.quadrants.not_urgent_important,
                    color: 'bg-blue-50 border-blue-300',
                    headerColor: 'bg-blue-500'
                },
                urgent_not_important: {
                    ...t.quadrants.urgent_not_important,
                    color: 'bg-yellow-50 border-yellow-300',
                    headerColor: 'bg-yellow-500'
                },
                not_urgent_not_important: {
                    ...t.quadrants.not_urgent_not_important,
                    color: 'bg-gray-50 border-gray-300',
                    headerColor: 'bg-gray-500'
                }
            };

            const addTask = async (quadrantId) => {
                if (newTask.trim()) {
                    const newTaskObj = {
                        id: Date.now(),
                        text: newTask,
                        quadrant: quadrantId,
                        order: tasks.filter(t => t.quadrant === quadrantId).length,
                        createdAt: new Date().toISOString(),
                        translations: {
                            [language]: newTask
                        },
                        sourceLang: language
                    };
                    
                    setTasks([...tasks, newTaskObj]);
                    setNewTask('');
                    setSelectedQuadrant(null);
                    
                    const otherLangs = Object.keys(translations).filter(lang => lang !== language);
                    for (const lang of otherLangs) {
                        const translated = await translateText(newTask, lang, language);
                        setTasks(prev => prev.map(t => 
                            t.id === newTaskObj.id 
                                ? { ...t, translations: { ...t.translations, [lang]: translated } }
                                : t
                        ));
                    }
                }
            };

            const deleteTask = (taskId) => {
                setTasks(tasks.filter(t => t.id !== taskId));
            };

            const startEditTask = (task) => {
                setEditingTask(task.id);
                setEditText(task.translations?.[language] || task.text);
            };

            const saveEditTask = (taskId) => {
                setTasks(prev => prev.map(t => 
                    t.id === taskId 
                        ? { ...t, translations: { ...t.translations, [language]: editText } }
                        : t
                ));
                setEditingTask(null);
                setEditText('');
            };

            const cancelEdit = () => {
                setEditingTask(null);
                setEditText('');
            };

            // Touch event handlers for mobile
            const handleTouchStart = (e, task) => {
                console.log('Touch start on:', task.text);
                setDraggedTask(task);
                setTouchStartY(e.touches[0].clientY);
                e.currentTarget.style.opacity = '0.5';
            };

            const handleTouchMove = (e, quadrantId) => {
                if (!draggedTask) return;
                
                e.preventDefault();
                setTouchCurrentY(e.touches[0].clientY);
                
                // Find which element we're over
                const touch = e.touches[0];
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                
                // Check if we're over a task
                const taskElement = elementBelow?.closest('[data-task-id]');
                if (taskElement) {
                    const taskId = parseInt(taskElement.getAttribute('data-task-id'));
                    const overTask = tasks.find(t => t.id === taskId);
                    if (overTask && overTask.id !== draggedTask.id) {
                        console.log('Over task:', overTask.text);
                        setDragOverTask(overTask);
                        setDragOverQuadrant(overTask.quadrant);
                        return;
                    }
                }
                
                // Check if we're over a quadrant
                const quadrantElement = elementBelow?.closest('[data-quadrant]');
                if (quadrantElement) {
                    const quadrant = quadrantElement.getAttribute('data-quadrant');
                    console.log('Over quadrant:', quadrant);
                    setDragOverQuadrant(quadrant);
                    setDragOverTask(null);
                } else {
                    setDragOverTask(null);
                }
            };

            const handleTouchEnd = (e, quadrantId) => {
                console.log('Touch end');
                if (!draggedTask) return;
                
                e.currentTarget.style.opacity = '1';
                
                let newTasks = [...tasks];
                let orderUpdated = false;
                
                // Case 1: Reorder within same quadrant
                if (dragOverTask && draggedTask.quadrant === dragOverTask.quadrant) {
                    console.log('Reordering within quadrant (touch)');
                    const quadrantTasks = newTasks
                        .filter(t => t.quadrant === dragOverTask.quadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    const draggedIndex = quadrantTasks.findIndex(t => t.id === draggedTask.id);
                    const targetIndex = quadrantTasks.findIndex(t => t.id === dragOverTask.id);
                    
                    console.log('Touch indexes:', { draggedIndex, targetIndex });
                    
                    const [removed] = quadrantTasks.splice(draggedIndex, 1);
                    quadrantTasks.splice(targetIndex, 0, removed);
                    
                    console.log('Touch new order:', quadrantTasks.map(t => t.text));
                    
                    quadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    orderUpdated = true;
                }
                // Case 2: Move to different quadrant
                else if (dragOverQuadrant && draggedTask.quadrant !== dragOverQuadrant) {
                    console.log('Moving to different quadrant (touch)');
                    
                    // First, update the dragged task's quadrant
                    const targetQuadrantTasks = newTasks.filter(t => t.quadrant === dragOverQuadrant && t.id !== draggedTask.id);
                    const newOrder = dragOverTask 
                        ? targetQuadrantTasks.findIndex(t => t.id === dragOverTask.id)
                        : targetQuadrantTasks.length;
                    
                    newTasks = newTasks.map(t => 
                        t.id === draggedTask.id 
                            ? { ...t, quadrant: dragOverQuadrant, order: newOrder }
                            : t
                    );
                    
                    // Reorder source quadrant
                    const sourceQuadrantTasks = newTasks
                        .filter(t => t.quadrant === draggedTask.quadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    sourceQuadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    // Reorder target quadrant
                    const updatedTargetTasks = newTasks
                        .filter(t => t.quadrant === dragOverQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    updatedTargetTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                    
                    orderUpdated = true;
                }
                
                if (orderUpdated) {
                    console.log('Saving updated task order');
                    setTasks(newTasks);
                }
                
                setDraggedTask(null);
                setDragOverTask(null);
                setDragOverQuadrant(null);
                setTouchStartY(null);
                setTouchCurrentY(null);
            };

            // Drag and drop handlers (for desktop/mouse)
            const handleDragStart = (e, task) => {
                setDraggedTask(task);
                e.currentTarget.classList.add('dragging');
            };

            const handleDragEnd = (e) => {
                e.currentTarget.classList.remove('dragging');
                setDraggedTask(null);
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const handleDragOver = (e, quadrantId, overTask = null) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
                setDragOverQuadrant(quadrantId);
                setDragOverTask(overTask);
            };

            const handleDragLeave = () => {
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const handleDrop = (e, targetQuadrant, targetTask = null) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (!draggedTask) {
                    console.log('No dragged task');
                    return;
                }

                console.log('Drop triggered:', {
                    draggedTask: draggedTask.text,
                    targetQuadrant,
                    targetTask: targetTask?.text || 'quadrant bottom',
                    sameQuadrant: draggedTask.quadrant === targetQuadrant
                });

                let newTasks = [...tasks];
                
                if (targetTask && draggedTask.quadrant === targetQuadrant) {
                    // Reorder within same quadrant
                    console.log('Reordering within quadrant');
                    const quadrantTasks = newTasks
                        .filter(t => t.quadrant === targetQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    const draggedIndex = quadrantTasks.findIndex(t => t.id === draggedTask.id);
                    const targetIndex = quadrantTasks.findIndex(t => t.id === targetTask.id);
                    
                    console.log('Indexes:', { draggedIndex, targetIndex });
                    
                    // Remove dragged task
                    const [removed] = quadrantTasks.splice(draggedIndex, 1);
                    // Insert at target position
                    quadrantTasks.splice(targetIndex, 0, removed);
                    
                    console.log('New order:', quadrantTasks.map(t => t.text));
                    
                    // Update order for all tasks in this quadrant
                    quadrantTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                } else if (draggedTask.quadrant !== targetQuadrant) {
                    // Move to different quadrant
                    console.log('Moving to different quadrant');
                    const targetQuadrantTasks = newTasks.filter(t => t.quadrant === targetQuadrant);
                    const newOrder = targetTask 
                        ? targetQuadrantTasks.findIndex(t => t.id === targetTask.id)
                        : targetQuadrantTasks.length;
                    
                    // Update moved task
                    newTasks = newTasks.map(t => 
                        t.id === draggedTask.id 
                            ? { ...t, quadrant: targetQuadrant, order: newOrder }
                            : t
                    );
                    
                    // Reorder all tasks in target quadrant
                    const updatedTargetTasks = newTasks
                        .filter(t => t.quadrant === targetQuadrant)
                        .sort((a, b) => (a.order || 0) - (b.order || 0));
                    
                    updatedTargetTasks.forEach((task, index) => {
                        const taskIndex = newTasks.findIndex(t => t.id === task.id);
                        newTasks[taskIndex] = { ...newTasks[taskIndex], order: index };
                    });
                }
                
                console.log('Updating tasks state');
                setTasks(newTasks);
                setDraggedTask(null);
                setDragOverQuadrant(null);
                setDragOverTask(null);
            };

            const getTasksByQuadrant = (quadrantId) => {
                return tasks
                    .filter(t => t.quadrant === quadrantId)
                    .sort((a, b) => (a.order || 0) - (b.order || 0));
            };

            const getTaskText = (task) => {
                return task.translations?.[language] || task.text;
            };

            const exportData = () => {
                const dataStr = JSON.stringify(tasks, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `genius-matrix-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                setShowMenu(false);
            };

            const importData = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const imported = JSON.parse(e.target.result);
                            setTasks(imported);
                            alert(t.importSuccess);
                        } catch (error) {
                            alert(t.importError);
                        }
                    };
                    reader.readAsText(file);
                }
                setShowMenu(false);
            };

            const clearAllTasks = () => {
                if (confirm(t.clearConfirm)) {
                    setTasks([]);
                }
                setShowMenu(false);
            };

            const languageNames = {
                en: 'EN', ro: 'RO'
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-100 to-slate-200">
                    <div className="bg-slate-800 text-white p-4 sticky top-0 z-40 shadow-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <h1 className="text-xl font-bold">{t.appTitle}</h1>
                                <p className="text-xs text-slate-300">{t.appSubtitle}</p>
                                {isTranslating && (
                                    <p className="text-xs text-blue-300 mt-1">{t.translating}</p>
                                )}
                            </div>
                            <button
                                onClick={() => setShowMenu(!showMenu)}
                                className="p-2 hover:bg-slate-700 rounded-lg transition-colors"
                            >
                                {showMenu ? <X /> : <Menu />}
                            </button>
                        </div>
                    </div>

                    {showMenu && (
                        <div className="bg-white border-b-2 border-slate-200 p-4 space-y-2 shadow-lg">
                            <div className="bg-slate-100 rounded-lg p-3 mb-2">
                                <div className="flex items-center gap-2 mb-2">
                                    <Globe size={18} />
                                    <span className="text-sm font-semibold text-slate-700">{t.language}</span>
                                </div>
                                <div className="flex gap-2">
                                    {Object.keys(translations).map((lang) => (
                                        <button
                                            key={lang}
                                            onClick={() => {
                                                setLanguage(lang);
                                                setShowMenu(false);
                                            }}
                                            className={`flex-1 px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                                                language === lang
                                                    ? 'bg-blue-500 text-white'
                                                    : 'bg-white text-slate-600 active:bg-slate-50'
                                            }`}
                                        >
                                            {languageNames[lang]}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <button
                                onClick={exportData}
                                className="w-full p-3 bg-blue-500 text-white rounded-lg flex items-center justify-center gap-2 font-medium active:bg-blue-600"
                            >
                                <Download />
                                {t.exportTasks}
                            </button>
                            <label className="w-full p-3 bg-green-500 text-white rounded-lg flex items-center justify-center gap-2 font-medium active:bg-green-600 cursor-pointer">
                                <Upload />
                                {t.importTasks}
                                <input
                                    type="file"
                                    accept=".json"
                                    onChange={importData}
                                    className="hidden"
                                />
                            </label>
                            <button
                                onClick={clearAllTasks}
                                className="w-full p-3 bg-red-500 text-white rounded-lg font-medium active:bg-red-600"
                            >
                                {t.clearAll}
                            </button>
                        </div>
                    )}

                    <div className="p-4 pb-20 space-y-4">
                        {Object.entries(quadrants).map(([key, quadrant]) => (
                            <div
                                key={key}
                                data-quadrant={key}
                                className={`${quadrant.color} border-2 rounded-xl shadow-lg overflow-hidden transition-all ${
                                    dragOverQuadrant === key ? 'drag-over' : ''
                                }`}
                                onDragOver={(e) => handleDragOver(e, key)}
                                onDragLeave={handleDragLeave}
                                onDrop={(e) => handleDrop(e, key)}
                            >
                                <div className={`${quadrant.headerColor} text-white p-4`}>
                                    <div className="flex items-center gap-2 mb-1">
                                        <span className="text-2xl">{quadrant.emoji}</span>
                                        <h2 className="text-xl font-bold">{quadrant.title}</h2>
                                    </div>
                                    <p className="text-xs opacity-90">{quadrant.subtitle}</p>
                                </div>

                                <div className="p-4">
                                    <div className="bg-white rounded-lg px-3 py-2 mb-3 text-sm font-semibold text-slate-700">
                                        â†’ {quadrant.action}
                                    </div>

                                    <div className="space-y-2 mb-3 max-h-[300px] overflow-y-auto">
                                        {getTasksByQuadrant(key).length === 0 ? (
                                            <div className="text-center py-4 text-slate-400 text-sm italic">
                                                {t.noTasks}
                                            </div>
                                        ) : (
                                            getTasksByQuadrant(key).map(task => (
                                                <div
                                                    key={task.id}
                                                    data-task-id={task.id}
                                                    draggable={editingTask !== task.id}
                                                    onDragStart={(e) => handleDragStart(e, task)}
                                                    onDragEnd={handleDragEnd}
                                                    onDragOver={(e) => handleDragOver(e, key, task)}
                                                    onDrop={(e) => handleDrop(e, key, task)}
                                                    onTouchStart={(e) => handleTouchStart(e, task)}
                                                    onTouchMove={(e) => handleTouchMove(e, key)}
                                                    onTouchEnd={(e) => handleTouchEnd(e, key)}
                                                    className={`bg-white rounded-lg p-3 shadow-sm flex items-center gap-2 ${
                                                        isTranslating ? 'translating' : ''
                                                    } ${draggedTask?.id === task.id ? 'dragging' : ''} ${
                                                        dragOverTask?.id === task.id ? 'border-t-2 border-blue-500' : ''
                                                    }`}
                                                >
                                                    {editingTask !== task.id && (
                                                        <div className="text-slate-400">
                                                            <Move size={16} />
                                                        </div>
                                                    )}
                                                    
                                                    {editingTask === task.id ? (
                                                        <div className="flex-1 flex flex-col gap-2">
                                                            <input
                                                                type="text"
                                                                value={editText}
                                                                onChange={(e) => setEditText(e.target.value)}
                                                                className="w-full px-2 py-1 border border-blue-300 rounded text-sm focus:outline-none focus:border-blue-500"
                                                                autoFocus
                                                            />
                                                            <div className="flex gap-2">
                                                                <button
                                                                    onClick={() => saveEditTask(task.id)}
                                                                    className="flex-1 text-green-600 bg-green-50 py-1 rounded text-sm font-medium"
                                                                >
                                                                    {t.save}
                                                                </button>
                                                                <button
                                                                    onClick={cancelEdit}
                                                                    className="flex-1 text-gray-600 bg-gray-50 py-1 rounded text-sm font-medium"
                                                                >
                                                                    {t.cancel}
                                                                </button>
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <>
                                                            <span
                                                                className="text-sm text-slate-700 flex-1"
                                                                onClick={() => startEditTask(task)}
                                                            >
                                                                {getTaskText(task)}
                                                            </span>
                                                            <div className="flex gap-2">
                                                                <button
                                                                    onClick={() => speakTask(getTaskText(task))}
                                                                    className="text-green-500 p-1"
                                                                    title={t.speak}
                                                                >
                                                                    <Volume2 size={20} />
                                                                </button>
                                                                <button
                                                                    onClick={() => startEditTask(task)}
                                                                    className="text-blue-500 p-1"
                                                                >
                                                                    <Edit2 size={16} />
                                                                </button>
                                                                <button
                                                                    onClick={() => deleteTask(task.id)}
                                                                    className="text-red-500 p-1"
                                                                >
                                                                    <Trash2 size={16} />
                                                                </button>
                                                            </div>
                                                        </>
                                                    )}
                                                </div>
                                            ))
                                        )}
                                    </div>

                                    <button
                                        onClick={() => setSelectedQuadrant(key)}
                                        className="w-full py-3 px-4 bg-white border-2 border-dashed border-slate-300 rounded-lg text-slate-600 active:bg-slate-50 transition-all flex items-center justify-center gap-2 font-medium"
                                    >
                                        <Plus size={20} />
                                        <span>{t.addTask}</span>
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>

                    {selectedQuadrant && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-end justify-center z-50">
                            <div className="bg-white rounded-t-2xl w-full max-h-[80vh] overflow-y-auto">
                                <div className="p-5">
                                    <div className="flex items-center gap-2 mb-3">
                                        <span className="text-3xl">{quadrants[selectedQuadrant].emoji}</span>
                                        <div>
                                            <h3 className="text-xl font-bold text-slate-800">
                                                {quadrants[selectedQuadrant].title}
                                            </h3>
                                            <p className="text-xs text-slate-600">
                                                {quadrants[selectedQuadrant].description}
                                            </p>
                                        </div>
                                    </div>
                                    <textarea
                                        value={newTask}
                                        onChange={(e) => setNewTask(e.target.value)}
                                        placeholder={t.enterTask}
                                        className="w-full px-4 py-3 border-2 border-slate-300 rounded-lg focus:outline-none focus:border-blue-500 mb-3 resize-none text-base"
                                        rows="4"
                                        autoFocus
                                    />
                                    <button
                                        onClick={startVoiceInput}
                                        disabled={isListening}
                                        className={`w-full mb-4 py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-base font-medium transition-colors ${
                                            isListening 
                                                ? 'bg-red-500 text-white animate-pulse' 
                                                : 'bg-purple-500 text-white active:bg-purple-600'
                                        }`}
                                    >
                                        <Mic size={24} />
                                        {isListening ? 'ðŸ”´ ' + t.listening : t.voiceInput}
                                    </button>
                                    {isListening && (
                                        <div className="mb-4 p-3 bg-yellow-100 border-2 border-yellow-400 rounded-lg text-sm">
                                            ðŸŽ¤ <strong>Listening...</strong> Speak now! Your speech will appear above.
                                        </div>
                                    )}
                                    <div className="space-y-3">
                                        <button
                                            onClick={() => addTask(selectedQuadrant)}
                                            className="w-full bg-blue-500 text-white py-4 px-4 rounded-lg active:bg-blue-600 transition-colors font-medium text-lg"
                                        >
                                            {t.addTask}
                                        </button>
                                        <button
                                            onClick={() => {
                                                setSelectedQuadrant(null);
                                                setNewTask('');
                                            }}
                                            className="w-full bg-slate-200 text-slate-700 py-4 px-4 rounded-lg active:bg-slate-300 transition-colors font-medium text-lg"
                                        >
                                            {t.cancel}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 p-3 text-center text-xs text-slate-500">
                        {t.tasksSaved} â€¢ {tasks.length} {t.totalTasks}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<DecisionMatrix />, document.getElementById('root'));
    </script>
</body>
</html>
